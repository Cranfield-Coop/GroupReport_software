import streamlit as st
import pandas as pd
import numpy as np
import pysindy as ps
import sys
import time
from io import StringIO
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error
from utils.PySINDy.psindy import *


# Define the relevant columns for the PySINDy model 
columns = ["y^+", "U", "Re_tau", "u'u'", "v'v'", "w'w'", "u'v'", "P", "dU/dy"]

def app():
    """
    Creation of a module for predicting turbulence modelling using PySINDy for the Streamlit application.
    """

    st.write("# Turbulence Modelling Predictor")
    st.markdown('<p style="font-size: 15px; font-style: italic;"> ~Developed by Group 2 Cranfield CO-OP</p>',unsafe_allow_html=True) 
    
    # File uploader for users to upload a CSV file
    uploaded_file_pysindy = st.file_uploader("\n\n**Please upload the CSV below.**", type=['csv'], key="PySINDy")
    
    # Check if a csv file has been uploaded
    if uploaded_file_pysindy is not None:
        st.success("File successfully uploaded!")
        df = pd.read_csv(uploaded_file_pysindy)
        
        # Check if the uploaded CSV file contains all the necessary columns
        if all(col in df.columns for col in columns):
            df = df[columns]
        else:
            st.error("Please upload a csv file with the columns y^+, U, Re_tau, u'u', v'v', w'w', u'v', P and dU/dy to proceed.")
            return None
        
        Reynolds_Numbers = sorted(df["Re_tau"].unique(), reverse=True) # Obtain the different Reynolds numbers

        st.header("PySINDy Model")
        st.subheader("Data processing")

        # Select the processing mode
        mode_choice = st.selectbox("Choose processing mode:", ['Data with interpolation', 'Data without interpolation'])
        
        if mode_choice == 'Data with interpolation':
            # Input for number of points to interpolate
            nb_interpolation = st.number_input("Please enter the number of data points to be generated with interpolation:", min_value=5000, max_value=100000, value=10000,step=1000, key='nb_interp')
            
            # Check that the number of points to be interpolated meets the conditions
            condition = len(df[df["Re_tau"] == Reynolds_Numbers[-1]])
            if nb_interpolation <= condition:
                st.error(f"The number of data points to be generated by interpolation must be greater than the number of data points associated with the smallest Reynolds Number present in the csv file ({condition})")
                return None
            # Process data with interpolation
            data = data_processing(df, 1, nb_interpolation, Reynolds_Numbers)
        elif mode_choice == "Data without interpolation":
            # Process data with interpolation
            data = data_processing(df, 0, 0, Reynolds_Numbers)

        # If data processing is successful
        if data is not None:
            # Button for displaying or hiding raw DNS data visualisations
            if 'show_graph' not in st.session_state:
                st.session_state.show_graph = False
            if st.button('Show raw data visualizations'):
                st.session_state.show_graph = True
            if st.button('Hide raw data visualizations'):
                st.session_state.show_graph = False
            if st.session_state.show_graph:
                df = pd.concat(data.values(), ignore_index=True)
                plot(df, Reynolds_Numbers) # Call the function to plot the graphs for visualisation
            
            # Prepare the data for PySINDy
            X, y = data_PySINDy(data, Reynolds_Numbers)

            # Define the names of the elements that are going to be used in the model
            feature_names = ["U", "u'u'", "v'v'", "w'w'", "u'v'", "P","dU/dy", "du'u'/dy", "dv'v'/dy", "dw'w'/dy", "du'v'/dy", "dP/dy"]
            
            # Set the feature_library parameter
            feature_library = ps.PolynomialLibrary(1)
            
            # Hyperparameter selection for the PySINDy Model
            st.subheader("Selection of PySINDy hyperparameters")

            # Input the value of the threshold and alpha coefficient for the STLSQ optimizer
            threshold_value = st.number_input(
                "Please enter the threshold value for the PySINDy optimiser:", value=0.001, min_value=0.0, format="%.6f")
            alpha_coeff = st.number_input(
                "Please enter the alpha coefficient for the PySINDy optimiser:", value=0.01, min_value=0.0, format="%.6f")             

            # If the csv file contains data associated with more than one reynolds number
            if len(Reynolds_Numbers) > 1:
                # Select the DNS data of the Reynolds Number 5200 for the training data and the DNS data of the Reynolds Number 2000 for the test data
                X_train = X[0]
                y_train = y[0]
                X_test = X[1]
                y_test = y[1]
            
            #If the csv file contains data associated with one reynolds number
            else:
                # Input the ratio for the data split in training and test datasets
                ratio = st.number_input("Please enter the ratio to split the data into training and testing datasets:", value=0.8,min_value=0.0,max_value=1.0,format="%.2f")
                X_1 = X[0]
                y_1 = y[0]
                ratio_split = int(len(X_1) * ratio)
                X_train = X_1[:ratio_split]
                X_test = X_1[ratio_split:]
                y_train = y_1[:ratio_split]
                y_test = y_1[ratio_split:]

            # Run model and display outputs
            if 'run_model' not in st.session_state:
                st.session_state.run_model = False

            if st.button('Run Model'):
                st.session_state.run_model = True

            if st.session_state.run_model:
                timer_start = time.time()

                # Define the STLSQ optimizer and its parameters
                optimizer = ps.STLSQ(threshold=threshold_value, alpha=alpha_coeff)

                # Create the SYNDy model with the specified parameters 
                model= ps.SINDy(feature_library=feature_library, optimizer=optimizer, feature_names=feature_names)
                
                # Fit the model on the training data
                model.fit(X_train, x_dot=y_train)
                
                timer_stop = time.time()

                # Display the equations of the PySINDY model in the Streamlit application
                st.subheader("PySINDy Output")
                old_stdout = sys.stdout
                sys.stdout = buffer = StringIO()
                model.print()
                sys.stdout = old_stdout
                model_output = buffer.getvalue()
                st.write("PySINDy Model - Equations")
                st.text(model_output)

                # Display the metrics of the PySINDY model in the Streamlit application
                st.subheader("Metrics")

                # Checks whether the sparsity coefficient is too large and therefore eliminates some coefficients from the PySINDY model
                sparsity = 0
                for i in range (len(model.optimizer.coef_)):
                    if np.all(model.optimizer.coef_[i] == 0):
                        sparsity = -1
                if sparsity == -1:
                    st.error(f"Sparsity parameter is too big ({threshold_value}) and eliminated all coefficients!") 
                else:
                    # Use the model to predict values based on the test features
                    y_pred = model.predict(X_test)
                    y_true = y_test

                    # Compute the R-squared value
                    r2 = r2_score(y_true, y_pred)
                    print(f"R-square: {r2}")

                    # Compute the MSE value    
                    mse = mean_squared_error(y_true, y_pred)
                    print(f"MSE: {mse}")

                    # Display the training execution time for the PySINDy model
                    st.metric("Excecution time",
                          value=f"{timer_stop - timer_start:.2f} seconds",
                          delta=None,
                          delta_color="normal",
                          help=None,
                          label_visibility="visible")

                    # Display the R-squared of the trained PySINDy model
                    st.metric(label="R-Squared", 
                              value=f"{r2:.10f}",
                              delta=None,
                              delta_color="normal",
                              help=None,
                              label_visibility="visible")
                    
                    # Display the MSE of the trained PySINDy model
                    st.metric(label="Mean Squared Error",
                              value=f"{mse:.10f}",
                              delta=None,
                              delta_color="normal",
                              help=None,
                              label_visibility="visible")

                    # Check if the PySINDy model is overfitting
                    test_overfitting(X_train, y_train, X_test, y_test, model)

                    # Run the simulation of the PySINDy model
                    st.subheader("PySINDy Simulation")
                    if len(Reynolds_Numbers)> 1:
                        solution = simulation(X_test, data[f"df_{Reynolds_Numbers[1]}"], model)
                    else:
                        solution = simulation(X_test, data[f"df_{Reynolds_Numbers[1]}"], model)
                    
                    if len(Reynolds_Numbers) > 1:
                        # Display simulation results in graph form
                        simulation_plot(data[f"df_{Reynolds_Numbers[1]}"], solution)

                        # Create a dataframe from the simulation results
                        df_sim = pd.DataFrame({"y^+":solution.t,'U': solution.y[0], "u'u'": solution.y[1], "v'v'": solution.y[2], "w'w'": solution.y[3], "u'v'": solution.y[4]})
                        
                        # Select the DNS data to only include the points that correspond to the simulation timesteps
                        df_pred = data[f"df_{Reynolds_Numbers[1]}"][data[f"df_{Reynolds_Numbers[1]}"]['y^+'].isin(solution.t)]
                        
                        # Compute the MAE between simulation results and DNS data 
                        mae_sim = mean_absolute_error(df_pred[["U","u'u'","v'v'","w'w'","u'v'"]].values,df_sim[["U","u'u'","v'v'","w'w'","u'v'"]].values)
                    else:
                        # Display simulation results in graph form
                        simulation_plot(data[f"df_{Reynolds_Numbers[0]}"], solution)
                        
                        # Create a dataframe from the simulation results
                        df_sim = pd.DataFrame({"y^+":solution.t,'U': solution.y[0], "u'u'": solution.y[1], "v'v'": solution.y[2], "w'w'": solution.y[3], "u'v'": solution.y[4]})
                        
                        # Select the DNS data to only include the points that correspond to the simulation timesteps
                        df_pred = data[f"df_{Reynolds_Numbers[0]}"][data[f"df_{Reynolds_Numbers[0]}"]['y^+'].isin(solution.t)]
                        
                        # Compute the MAE between simulation results and DNS data 
                        mae_sim = mean_absolute_error(df_pred[["U","u'u'","v'v'","w'w'","u'v'"]].values,df_sim[["U","u'u'","v'v'","w'w'","u'v'"]].values)

                    if mae_sim < 1:
                        st.write(
                            "The PySINDy model successfully generates equations with physical meaning, and the model simulation is highly accurate.")
                    elif mae_sim < 5:
                        st.write(
                            "The PySINDy model successfully generates equations with physical meaning, and the model simulation is quite accurate.")
                    elif mae_sim > 5:
                        st.write(
                            "The PySINDy model is unable to generate equations with physical meaning, and the simulation of the model is not very accurate.")
                    
                    csv = df_sim.to_csv(index=False).encode('utf-8')
                    # Button to download the predicted values after the model simulation
                    st.download_button(
                        label="Download Prediction Results",
                        data=csv,
                        file_name='prediction_output_pysindy.csv',
                        mime='text/csv',
                    )
    else:
        # Error message if no file is uploaded
        st.error("Please upload a csv file to proceed.")
                
